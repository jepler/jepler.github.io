---
layout: post
title: "Proven Delights (and what are proofs anyway)"
redirect_from: 
 - /01438780429
---
<body>


I won a copy of the book <a href="http://hackersdelight.org/">Hacker's
Delight</a> from <a href="http://blog.regehr.org/">John Regehr</a> for my entry in
his <a href="http://blog.regehr.org/archives/1213">nibble sort contest</a>
earlier this year.

<p>In that thread I had heard about the <a href="http://www.cprover.org/cbmc/">CBMC Bounded Model Checking software</a>, and it gave me the idea to combine
the two: a project to take implementations of the algorithms from Hacker's
Delight and prove the algorithms' properties with CBMC.

<p>I have a modest start on github, which I am calling &quot;Proven Delights&quot;:
<a href="http://jepler.github.io/ProvenDelights/">HTML</a>, <a href="http://jepler.github.io/ProvenDelights/proofs.pdf">PDF</a>, <a href="https://github.com/jepler/ProvenDelights">Source</a>.  I hope others will
find the concept interesting and submit github pull requests with new
proofs.

<p>Working more with CBMC has given me a sense of why mathematicians are not
fully embracing computer proofs in their work.  A traditional proof, like
you may have first made in high school geometry, serves two purposes: first,
it shows that the desired conclusion is true in a given axiomatic system;
but second, a traditional proof can be read by a fellow mathematician and lend
her some abstract understanding of <strong>why</strong> the conclusion
is true.

<p>It is from that abstract understanding that she may think of some new theorem
to prove.  But with a so-called &quot;proof&quot; from software like CBMC, you only learn
that the computer says the assertions in the model are not violated; there
is no step by step proof process that a human can learn from.  So when I have
finished writing a model that I think captures the claims about the expression
<tt >(x &amp; (x-1))</tt>, and CBMC says &quot;VERIFICATION SUCCESSFUL&quot;, I still don't understand
why the expression actually &quot;turns off the rightmost one-bit&quot;.

<p>Still, CBMC is pretty neat.  One of the proofs I wrote most recently, for
sec-ded error codes, proves in a few seconds what takes overnight with a
program to exhaustively check somewhere in excess of 2^41 distinct cases.
Not a bad speed-up!
<br><br><font size=-2>Entry first conceived on 5 August 2015, 13:13 UTC, last modified on 29 February 2016, 22:04 UTC</font>
</body>
</html>
